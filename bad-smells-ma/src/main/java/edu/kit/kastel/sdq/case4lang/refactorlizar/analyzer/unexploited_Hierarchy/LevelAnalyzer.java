package edu.kit.kastel.sdq.case4lang.refactorlizar.analyzer.unexploited_Hierarchy;

import com.google.common.graph.MutableNetwork;
import edu.kit.kastel.sdq.case4lang.refactorlizar.analyzer.api.Report;
import edu.kit.kastel.sdq.case4lang.refactorlizar.commons_analyzer.Components;
import edu.kit.kastel.sdq.case4lang.refactorlizar.commons_analyzer.DependencyGraphSupplier;
import edu.kit.kastel.sdq.case4lang.refactorlizar.commons_analyzer.Edge;
import edu.kit.kastel.sdq.case4lang.refactorlizar.commons_analyzer.JavaUtils;
import edu.kit.kastel.sdq.case4lang.refactorlizar.commons_analyzer.graphs.TypeGraphs;
import edu.kit.kastel.sdq.case4lang.refactorlizar.model.Component;
import edu.kit.kastel.sdq.case4lang.refactorlizar.model.ModularLanguage;
import edu.kit.kastel.sdq.case4lang.refactorlizar.model.SimulatorModel;
import java.util.HashSet;
import java.util.Optional;
import java.util.Set;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.stream.Collectors;
import spoon.reflect.declaration.CtType;
import spoon.reflect.declaration.CtTypeMember;

public class LevelAnalyzer {
    private static final String UNKNOWN_LAYER_IDENTIFIER = "UNKNOWN";
    private ModularLanguage language;
    private SimulatorModel model;

    public LevelAnalyzer(ModularLanguage language, SimulatorModel model) {
        this.language = language;
        this.model = model;
    }

    public Report fullAnalysis() {
        return findTypeImproperDependencyLayer(language, model);
    }

    private Report findTypeImproperDependencyLayer(ModularLanguage language, SimulatorModel model) {
        MutableNetwork<CtType<?>, Edge<CtType<?>, CtTypeMember>> graph =
                DependencyGraphSupplier.getTypeGraph(language, model);
        TypeGraphs.removeNonProjectNodes(language, model, graph);
        removeNodesWithoutLayer(
                graph,
                (CtType<?> v) ->
                        Components.findComponent(model, language, v)
                                .map(this::isUnknownLayer)
                                .orElse(true));
        removeProperLayerEdgesType(language, model, graph);
        return TypeLevelReportGeneration.generateReport(graph, model, language);
    }

    private void removeProperLayerEdgesType(
            ModularLanguage language,
            SimulatorModel model,
            MutableNetwork<CtType<?>, Edge<CtType<?>, CtTypeMember>> graph) {
        removeProperLayerEdges(
                graph,
                type -> JavaUtils.isSimulatorType(model, type),
                type -> JavaUtils.isLanguageType(language, type),
                (type) -> Components.findComponent(model, type),
                (type) -> Components.findComponent(language, type));
    }

    private <T, U> void removeProperLayerEdges(
            MutableNetwork<T, Edge<T, U>> graph,
            Predicate<T> isSimulator,
            Predicate<T> isLanguage,
            Function<T, Optional<Component>> findSimulatorComponent,
            Function<T, Optional<Component>> findLanguageComponent) {
        Set<Edge<T, U>> removableEdges = new HashSet<>();

        for (T source : graph.nodes()) {
            Optional<Component> sourceComponent = findSimulatorComponent.apply(source);
            if (isLanguage.test(source) || sourceComponent.isEmpty()) {
                continue;
            }
            for (T target : graph.successors(source)) {
                Optional<Component> targetComponent = findLanguageComponent.apply(target);
                if (isSimulator.test(target) || targetComponent.isEmpty()) {
                    removableEdges.addAll(graph.edgesConnecting(source, target));
                } else {
                    if (getLayer(sourceComponent).equals(getLayer(targetComponent))) {
                        removableEdges.addAll(graph.edgesConnecting(source, target));
                    }
                }
            }
        }
        removableEdges.forEach(graph::removeEdge);
        graph.nodes().stream()
                .filter(v -> graph.degree(v) == 0)
                .collect(Collectors.toSet())
                .forEach(graph::removeNode);
    }

    private String getLayer(Optional<Component> sourceComponent) {
        return sourceComponent.get().getLayer();
    }

    private <T, U> void removeNodesWithoutLayer(
            MutableNetwork<T, Edge<T, U>> graph, Predicate<T> hasNoLayer) {
        graph.nodes().stream()
                .filter(hasNoLayer::test)
                .collect(Collectors.toList())
                .forEach(graph::removeNode);
    }

    private boolean isUnknownLayer(Component component) {
        return component.getLayer().equals(UNKNOWN_LAYER_IDENTIFIER);
    }
}
